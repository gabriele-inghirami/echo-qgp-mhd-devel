! ROUTINES TAKEN FROM THE ACM Digital Library 
! ALGORITHM 554, by
! JORGE J. MORE`, Argonne National Laboratory
! and
! MICHEL Y. COSNARD, Université Scientifique et Médicale de Grenoble
! Free use. For details about the licence, please, consult the ACM website.

      SUBROUTINE BRENTM(FCN,N,X,FVEC,FTOL,XTOL,MAXFEV,MOPT,INFO,NFEV,Q,LDQ,SIGMA,WA1,WA2)
      IMPLICIT NONE
      INTEGER N,MAXFEV,MOPT,INFO,NFEV,LDQ
      real(8) FTOL,XTOL
      real(8) X(N),FVEC(N),Q(LDQ,N),SIGMA(N),WA1(N),WA2(N)
!     **********
!
!     SUBROUTINE BRENTM
!
!     THE PURPOSE OF THIS SUBROUTINE IS TO FIND A ZERO TO
!     A SYSTEM OF N NONLINEAR EQUATIONS IN N VARIABLES BY A
!     METHOD DUE TO R. BRENT.
!
!     THE SUBROUTINE STATEMENT IS
!
!       SUBROUTINE BRENTM(FCN,N,X,FVEC,FTOL,XTOL,MAXFEV,MOPT,
!                         INFO,NFEV,Q,LDQ,SIGMA,WA1,WA2)
!
!     WHERE
!
!       FCN IS THE NAME OF THE USER-SUPPLIED SUBROUTINE WHICH
!         CALCULATES COMPONENTS OF THE FUNCTION. FCN SHOULD BE
!         DECLARED IN AN EXTERNAL STATEMENT IN THE USER CALLING
!         PROGRAM, AND SHOULD BE WRITTEN AS FOLLOWS.
!
!         SUBROUTINE FCN(N,X,FVEC,IFLAG)
!         INTEGER N,IFLAG
!         DOUBLE PRECISION X(N),FVEC(N)
!         ----------
!         CALCULATE THE IFLAG-TH COMPONENT OF THE FUNCTION
!         AND RETURN THIS VALUE IN FVEC(IFLAG).
!         ----------
!         RETURN
!         END
!
!         THE VALUE OF IFLAG SHOULD NOT BE CHANGED BY FCN UNLESS
!         THE USER WANTS TO TERMINATE EXECUTION OF BRENTM.
!         IN THIS CASE SET IFLAG TO A NEGATIVE INTEGER.
!
!       N IS A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER OF
!         EQUATIONS AND VARIABLES.
!
!       X IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN
!         AN ESTIMATE TO THE SOLUTION OF THE SYSTEM OF EQUATIONS.
!         ON OUTPUT X CONTAINS THE FINAL ESTIMATE TO THE SOLUTION
!         OF THE SYSTEM OF EQUATIONS.
!
!       FVEC IS AN ARRAY OF LENGTH N. ON OUTPUT IT CONTAINS
!         THE FINAL RESIDUALS.
!
!       FTOL IS A NONNEGATIVE INPUT VARIABLE. CONVERGENCE
!         OCCURS IF ALL RESIDUALS ARE AT MOST FTOL IN MAGNITUDE.
!
!       XTOL IS A NONNEGATIVE INPUT VARIABLE. CONVERGENCE
!         OCCURS IF THE RELATIVE ERROR BETWEEN TWO SUCCESSIVE
!         ITERATES IS AT MOST XTOL.
!
!       MAXFEV IS A POSITIVE INTEGER INPUT VARIABLE. TERMINATION
!         OCCURS IF THE NUMBER OF FUNCTION EVALUATIONS IS AT
!         LEAST MAXFEV BY THE END OF AN ITERATION. IN BRENTM,
!         A FUNCTION EVALUATION CORRESPONDS TO N CALLS TO FCN.
!
!       MOPT IS A POSITIVE INTEGER INPUT VARIABLE. MOPT SPECIFIES
!         THE NUMBER OF TIMES THAT THE APPROXIMATE JACOBIAN IS
!         USED DURING EACH ITERATION WHICH EMPLOYS ITERATIVE
!         REFINEMENT. IF MOPT IS 1, NO ITERATIVE REFINEMENT WILL
!         BE DONE. MAXIMUM EFFICIENCY IS USUALLY OBTAINED IF
!         MOPT MAXIMIZES LOG(K+1)/(N+2*K+1) FOR K = 1,...,N.
!
!       INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS. IF
!         THE USER HAS TERMINATED EXECUTION, INFO WILL BE SET TO
!         THE (NEGATIVE) VALUE OF IFLAG. SEE DESCRIPTION OF FCN.
!         OTHERWISE
!
!         INFO = 0   IMPROPER INPUT PARAMETERS.
!
!         INFO = 1   ALL RESIDUALS ARE AT MOST FTOL IN MAGNITUDE.
!
!         INFO = 2   RELATIVE ERROR BETWEEN TWO SUCCESSIVE ITERATES
!                    IS AT MOST XTOL.
!
!         INFO = 3   CONDITIONS FOR INFO = 1 AND INFO = 2 BOTH HOLD.
!
!         INFO = 4   NUMBER OF FUNCTION EVALUATIONS HAS REACHED OR
!                    EXCEEDED MAXFEV.
!
!         INFO = 5   APPROXIMATE JACOBIAN MATRIX IS SINGULAR.
!
!         INFO = 6   ITERATION IS NOT MAKING GOOD PROGRESS.
!
!         INFO = 7   ITERATION IS DIVERGING.
!
!         INFO = 8   ITERATION IS CONVERGING, BUT XTOL IS TOO
!                    SMALL, OR THE CONVERGENCE IS VERY SLOW
!                    DUE TO A JACOBIAN SINGULAR NEAR THE OUTPUT
!                    X OR DUE TO BADLY SCALED VARIABLES.
!
!       NFEV IS AN INTEGER OUTPUT VARIABLE SET TO THE NUMBER OF
!         FUNCTION EVALUATIONS USED IN PRODUCING X. IN BRENTM,
!         A FUNCTION EVALUATION CORRESPONDS TO N CALLS TO FCN.
!
!       Q IS AN N BY N ARRAY. IF JAC DENOTES THE APPROXIMATE
!         JACOBIAN, THEN ON OUTPUT Q IS (A MULTIPLE OF) AN
!         ORTHOGONAL MATRIX SUCH THAT JAC*Q IS A LOWER TRIANGULAR
!         MATRIX. ONLY THE DIAGONAL ELEMENTS OF JAC*Q NEED
!         TO BE STORED, AND THESE CAN BE FOUND IN SIGMA.
!
!       LDQ IS A POSITIVE INTEGER INPUT VARIABLE NOT LESS THAN N
!         WHICH SPECIFIES THE LEADING DIMENSION OF THE ARRAY Q.
!
!       SIGMA IS A LINEAR ARRAY OF LENGTH N. ON OUTPUT SIGMA
!         CONTAINS THE DIAGONAL ELEMENTS OF THE MATRIX JAC*Q.
!         SEE DESCRIPTION OF Q.
!
!       WA1 AND WA2 ARE LINEAR WORK ARRAYS OF LENGTH N.
!
!     SUBPROGRAMS REQUIRED
!
!       USER-SUPPLIED ...... FCN
!
!       FORTRAN-SUPPLIED ... DABS,DMAX1,DSQRT,DSIGN
!
!     **********
      INTEGER I,IFLAG,J,K,M,NFCALL,NIER6,NIER7,NIER8,NSING
      LOGICAL CONV
      real(8) DELTA,DIFIT,DIFIT1,EPS,EPSMCH,ETA,FKY,FKZ,FNORM,FNORM1,H,P05,SCALE,SKNORM,TEMP,XNORM,ZERO
      DATA ZERO,P05,SCALE /0.D0,5.D-2,1.D1/

      EPSMCH = EPSILON(1.d0)
!
      INFO = 0
      IFLAG = 0
      NFEV = 0
      NFCALL = 0
!
!     CHECK THE INPUT PARAMETERS FOR ERRORS.
!
      IF (N .LE. 0 .OR. FTOL .LT. ZERO .OR. XTOL .LT. ZERO .OR. MAXFEV .LE. 0 .OR. MOPT .LE. 0 .OR. LDQ .LT. N) GO TO 220
!
!     INITIALIZE SOME OF THE VARIABLES.
!
      NIER6 = -1
      NIER7 = -1
      NIER8 = 0
      FNORM = ZERO
      DIFIT = ZERO
      XNORM = ZERO
      DO 10 I = 1, N
         XNORM = DMAX1(XNORM,DABS(X(I)))
   10    CONTINUE
      EPS = DSQRT(EPSMCH)
      DELTA = SCALE*XNORM
      IF (XNORM .EQ. ZERO) DELTA = SCALE
!
!     ENTER THE PRINCIPAL ITERATION.
!
   20 CONTINUE
!
!     TO PRINT THE ITERATES, PLACE WRITE STATEMENTS
!     FOR THE VECTOR X HERE.
!
      NSING = N
      FNORM1 = FNORM
      DIFIT1 = DIFIT
      FNORM = ZERO
!
!     COMPUTE THE STEP H FOR THE DIVIDED DIFFERENCE WHICH
!     APPROXIMATES THE K-TH ROW OF THE JACOBIAN MATRIX.
!
      H = EPS*XNORM
      IF (H .EQ. ZERO) H = EPS
      DO 40 J = 1, N
         DO 30 I = 1, N
            Q(I,J) = ZERO
   30       CONTINUE
         Q(J,J) = H
         WA1(J) = X(J)
   40    CONTINUE
!
!     ENTER A SUBITERATION.
!
      DO 150 K = 1, N
         IFLAG = K
         CALL FCN(N,WA1,FVEC,IFLAG)
         FKY = FVEC(K)
         NFCALL = NFCALL + 1
         NFEV = NFCALL/N
         IF (IFLAG .LT. 0) GO TO 230
         FNORM = DMAX1(FNORM,DABS(FKY))
!
!        COMPUTE THE K-TH ROW OF THE JACOBIAN MATRIX.
!
         DO 60 J = K, N
            DO 50 I = 1, N
               WA2(I) = WA1(I) + Q(I,J)
   50          CONTINUE
            CALL FCN(N,WA2,FVEC,IFLAG)
            FKZ = FVEC(K)
            NFCALL = NFCALL + 1
            NFEV = NFCALL/N
            IF (IFLAG .LT. 0) GO TO 230
            SIGMA(J) = FKZ - FKY
   60       CONTINUE
         FVEC(K) = FKY
!
!        COMPUTE THE HOUSEHOLDER TRANSFORMATION TO REDUCE THE K-TH ROW
!        OF THE JACOBIAN MATRIX TO A MULTIPLE OF THE K-TH UNIT VECTOR.
!
         ETA = ZERO
         DO 70 I = K, N
            ETA = DMAX1(ETA,DABS(SIGMA(I)))
   70       CONTINUE
         IF (ETA .EQ. ZERO) GO TO 150
         NSING = NSING - 1
         SKNORM = ZERO
         DO 80 I = K, N
            SIGMA(I) = SIGMA(I)/ETA
            SKNORM = SKNORM + SIGMA(I)**2
   80       CONTINUE
         SKNORM = DSQRT(SKNORM)
         IF (SIGMA(K) .LT. ZERO) SKNORM = -SKNORM
         SIGMA(K) = SIGMA(K) + SKNORM
!
!        APPLY THE TRANSFORMATION AND COMPUTE THE MATRIX Q.
!
         DO 90 I = 1, N
            WA2(I) = ZERO
   90       CONTINUE
         DO 110 J = K, N
            TEMP = SIGMA(J)
            DO 100 I = 1, N
               WA2(I) = WA2(I) + TEMP*Q(I,J)
  100          CONTINUE
  110       CONTINUE
         DO 130 J = K, N
            TEMP = SIGMA(J)/(SKNORM*SIGMA(K))
            DO 120 I = 1, N
               Q(I,J) = Q(I,J) - TEMP*WA2(I)
  120          CONTINUE
  130       CONTINUE
!
!        COMPUTE THE SUBITERATE.
!
         SIGMA(K) = SKNORM*ETA
         TEMP = FKY/SIGMA(K)
         IF (H*DABS(TEMP) .GT. DELTA) TEMP = DSIGN(DELTA/H,TEMP)
         DO 140 I = 1, N
            WA1(I) = WA1(I) + TEMP*Q(I,K)
  140       CONTINUE
  150    CONTINUE
!
!     COMPUTE THE NORMS OF THE ITERATE AND CORRECTION VECTOR.
!
      XNORM = ZERO
      DIFIT = ZERO
      DO 160 I = 1, N
         XNORM = DMAX1(XNORM,DABS(WA1(I)))
         DIFIT = DMAX1(DIFIT,DABS(X(I)-WA1(I)))
         X(I) = WA1(I)
  160    CONTINUE
!
!     UPDATE THE BOUND ON THE CORRECTION VECTOR.
!
      DELTA = DMAX1(DELTA,SCALE*XNORM)
!
!     DETERMINE THE PROGRESS OF THE ITERATION.
!
      CONV = (FNORM .LT. FNORM1 .AND. DIFIT .LT. DIFIT1 .AND. NSING .EQ. 0)
      NIER6 = NIER6 + 1
      NIER7 = NIER7 + 1
      NIER8 = NIER8 + 1
      IF (CONV) NIER6 = 0
      IF (FNORM .LT. FNORM1 .OR. DIFIT .LT. DIFIT1) NIER7 = 0
      IF (DIFIT .GT. EPS*XNORM) NIER8 = 0
!
!     TESTS FOR CONVERGENCE.
!
      IF (FNORM .LE. FTOL) INFO = 1
      IF (DIFIT .LE. XTOL*XNORM .AND. CONV) INFO = 2
      IF (FNORM .LE. FTOL .AND. INFO .EQ. 2) INFO = 3
      IF (INFO .NE. 0) GO TO 230
!
!     TESTS FOR TERMINATION.
!
      IF (NFEV .GE. MAXFEV) INFO = 4
      IF (NSING .EQ. N) INFO = 5
      IF (NIER6 .EQ. 5) INFO = 6
      IF (NIER7 .EQ. 3) INFO = 7
      IF (NIER8 .EQ. 4) INFO = 8
      IF (INFO .NE. 0) GO TO 230
!
!     ITERATIVE REFINEMENT IS USED IF THE ITERATION IS CONVERGING.
!
      IF (.NOT. CONV .OR. DIFIT .GT. P05*XNORM .OR. MOPT .EQ. 1) GO TO 220
!
!     START ITERATIVE REFINEMENT.
!
      DO 210 M = 2, MOPT
         FNORM1 = FNORM
         FNORM = ZERO
         DO 190 K = 1, N
            IFLAG = K
            CALL FCN(N,WA1,FVEC,IFLAG)
            FKY = FVEC(K)
            NFCALL = NFCALL + 1
            NFEV = NFCALL/N
            IF (IFLAG .LT. 0) GO TO 230
            FNORM = DMAX1(FNORM,DABS(FKY))
!
!           ITERATIVE REFINEMENT IS TERMINATED IF IT DOES NOT
!           GIVE A REDUCTION OF THE RESIDUALS.
!
            IF (FNORM .LT. FNORM1) GO TO 170
            FNORM = FNORM1
            GO TO 220
  170       CONTINUE
            TEMP = FKY/SIGMA(K)
            DO 180 I = 1, N
               WA1(I) = WA1(I) + TEMP*Q(I,K)
  180          CONTINUE
  190       CONTINUE
!
!        COMPUTE THE NORMS OF THE ITERATE AND CORRECTION VECTOR.
!
         XNORM = ZERO
         DIFIT = ZERO
         DO 200 I = 1, N
            XNORM = DMAX1(XNORM,DABS(WA1(I)))
            DIFIT = DMAX1(DIFIT,DABS(X(I)-WA1(I)))
            X(I) = WA1(I)
  200       CONTINUE
!
!        STOPPING CRITERIA FOR ITERATIVE REFINEMENT.
!
         IF (FNORM .LE. FTOL) INFO = 1
         IF (DIFIT .LE. XTOL*XNORM) INFO = 2
         IF (FNORM .LE. FTOL .AND. INFO .EQ. 2) INFO = 3
         IF (NFEV .GE. MAXFEV .AND. INFO .EQ. 0) INFO = 4
         IF (INFO .NE. 0) GO TO 230
  210    CONTINUE
  220 CONTINUE
!
!     END OF THE ITERATIVE REFINEMENT.
!
      GO TO 20
!
!     TERMINATION, EITHER NORMAL OR USER IMPOSED.
!
  230 CONTINUE
      IF (IFLAG .LT. 0) INFO = IFLAG
      RETURN
!
!     LAST CARD OF SUBROUTINE BRENTM.
!
      END
